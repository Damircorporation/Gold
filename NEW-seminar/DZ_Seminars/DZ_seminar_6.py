# Задание 1. Модуль для подсчета количества повторений слов
# Создайте модуль с функцией, которая получает список слов и возвращает
# словарь, в котором ключи — это слова, а значения — количество их повторений
# в списке.

# # word_count.py
# def count_word_occurrences(words):
#     # Создаем пустой словарь для хранения количества
#     # повторений каждого слова
#     word_count = {}
#     # Проходим по каждому слову в списке
#     for word in words:
#     # Используем метод get() для получения текущего
#     # количества повторений слова
#     # Если слово не найдено, get() вернет 0, иначе
#     # увеличиваем текущий счетчик на 1
#     word_count[word] = word_count.get(word, 0) + 1
#     # Возвращаем словарь с количеством повторений слов
#     return word_count
# # Чтобы использовать модуль word_count, создайте файл с именем word_count.py и
# # вставьте в него код выше. Затем вы можете использовать его в другом скрипте
# # следующим образом:
# import word_count
#
# print(word_count.count_word_occurrences(['apple', 'banana', 'apple',
# 'orange'])) # Output: {'apple': 2, 'banana': 1, 'orange': 1}


# Задача 2. Модуль для удаления дублирующихся подряд символов
# Напишите модуль с функцией, которая принимает строку и возвращает строку с
# удаленными дублирующимися подряд идущими символами. Например, строка
# "aabbccaa" должна быть преобразована в "abca".

# # remove_duplicates.py
# def remove_consecutive_duplicates(s):
# # Если строка пуста, возвращаем её как есть
#     if not s:
#         return s
#     # Инициализируем список для хранения результата
#     result = [s[0]]
#     # Проходим по каждому символу в строке, начиная со второго
#     for char in s[1:]:
#     # Если текущий символ не совпадает с последним добавленным символом в result
#         if char != result[-1]:
#             # Добавляем текущий символ в результат
#             result.append(char)
#         # Преобразуем список символов обратно в строку и возвращаем её
#     return ''.join(result)
# # Чтобы использовать модуль remove_duplicates, создайте файл с именем
# # remove_duplicates.py и вставьте в него код выше. Затем вы можете использовать его в
# # другом скрипте следующим образом:
# import remove_duplicates

# print(remove_duplicates.remove_consecutive_duplicates('aaabbcaaa'))
# # Output: 'abca'


# Задача 3. Модуль для нахождения уникальных для обоих списков
# элементов
# Создайте модуль с функцией, которая принимает два списка и возвращает
# список, содержащий только элементы, которые уникальны для обоих списков.

# # unique_to_both_lists.py
#
# def unique_to_both_lists(list1, list2):
#     """
#     Функция для нахождения уникальных элементов в двух списках.
#     Аргументы:
#     list1 -- первый список
#     list2 -- второй список
#     Возвращает:
#     Список уникальных элементов, которые присутствуют только в одном
#     из двух списков.
#     """
#     # Преобразуем списки в множества для удобства
#     # операций с уникальными элементами
#     set1, set2 = set(list1), set(list2)
#     # Найдем элементы, которые уникальны для обоих множеств
#     unique_elements = (set1 - set2) | (set2 - set1)
#     # Преобразуем результат обратно в список и возвращаем его
#     return list(unique_elements)
# # Чтобы использовать модуль unique_to_both_lists, создайте файл с именем
# # unique_to_both_lists.py и вставьте в него код выше. Затем вы можете использовать его
# # в другом скрипте следующим образом:
# import unique_to_both_lists
#
# print(unique_to_both_lists.unique_to_both_lists([1, 2, 3], [3, 4,
# 5])) # Output: [1, 2, 4, 5]


# Задача 4. Модуль для проверки даты
# Создайте модуль и напишите в нём функцию, которая получает на вход дату в
# формате DD.MM.YYYY Функция возвращает истину, если дата может существовать
# или ложь, если такая дата невозможна. Для простоты договоримся, что год
# может быть в диапазоне [1, 9999]. Весь период (1 января 1 года - 31 декабря 9999
# года) действует Григорианский календарь. Проверку года на високосность
# вынести в отдельную защищённую функцию.

# # date_validator.py
# def _is_leap_year(year):
#     """
#     Возвращает True, если год високосный, иначе False.
#     Аргументы:
#     year -- год для проверки
#     Возвращает:
#     True, если год високосный; False в противном случае
#     """
#     return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)
#
# def is_valid_date(date_str):
#     """
#     Проверяет, является ли дата в формате DD.MM.YYYY валидной.
#     Аргументы:
#     date_str -- строка с датой в формате DD.MM.YYYY
#     Возвращает:
#     True, если дата валидная; False в противном случае
#     """
#     #   Проверяем длину строки
#     if len(date_str) != 10:
#         return False
#
#     # Разделяем строку даты на день, месяц и год
#     parts = date_str.split('.')
#     # Проверяем, что строка корректно разделилась на три части
#     if len(parts) != 3:
#         return False
#     # Проверяем, что все части являются целыми числами
#     try:
#         day, month, year = map(int, parts)
#     except ValueError:
#         return False
#     # Проверяем валидность месяца
#     if not (1 <= month <= 12):
#         return False
#     # Проверяем валидность дня в зависимости от месяца
#     if not (1 <= day <= 31):
#         return False
#     if month in [4, 6, 9, 11] and day > 30:
#         return False
#     if month == 2:
#         if _is_leap_year(year) and day > 29:
#             return False
#         elif not _is_leap_year(year) and day > 28:
#             return False
#     # Если все проверки пройдены, дата валидна
#     return True



